<!-- 반복문과 조건문-->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>반복문과 조건문</h1>
  </div>
  <p>이제 변수와 연산을 배웠습니다. 이것만을 활용해도 프로그램을 만들 수 있습니다. 하지만 더 복잡하고 다양한 작업을 위해서는 '반복과 조건'을 알아야 합니다 만약 10개의 수를 모두 더하는 프로그램을 만들어야 한다고 가정해 봅시다. 코드를 작성한다면 다음과 같을겁니다.</p>
  <pre class="line-numbers">
        <code class="language-java">public class main {
            public static void main(string[] args) {
                // 변수 선언
                int num1 = 1;
                int num2 = 2;
                int num3 = 3;
                int num4 = 4;
                ...                
                int num10 = 10;
                
                // 결과값 저장
                int result = 0;
           
                // 덧셈 진행
                result = result + num1;
                result = result + num2;
                result = result + num3;
                ...                
                result = result + num10;
                
                // 결과 저장
                system.out.println(result);
            }
        }</code>
    </pre>
  <p>해당 코드를 활용하면 1에서 10까지의 값을 모두 더할 수 있습니다. 하지만 만약 변수가 100개라면요? 100만개의 값을 대상으로 한다면 100만개의 변수를 모두 만들어야 할까요? 그렇다면 덧셈과 선언만 200만줄이 될 겁니다. 엄청난 양이죠. 효율적인 방법을 찾아봅시다.</p>

  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h2>반복문</h2>
  </div>

  <p>반복문은 일정한 코드를 원하는 수 만큼 반복하는 것을 목표로 합니다. 그 종류는 세가지를 사용할 수 있습니다.
    <code>for</code>,
    <code>while</code>, 그리고
    <code>do-while</code>입니다.
  </p>

  <ol>
    <li>for 문
      <p>
        <code>for</code>
        문은 반복 횟수가 명확할 때 주로 사용됩니다. 초기화, 조건식, 증감식을 한 줄에 작성하여 반복을 제어합니다.</p>
      <pre class="line-numbers">
    <code class="language-java">for (초기화; 조건식; 증감식) {
        // 반복 실행할 코드
    }</code>
    </pre>
      <ul>
        <li>초기화는
          <code>for</code>문 내부에서 활용할 변수를 선언함을 의미합니다.
          <code>for</code>문 내부에서만 생성되고 반복문이 종료되면 사라집니다.
        </li>
        <li>조건식은 반복문의 가장 처음에 그 조건이 참인지 거짓인지 확인하고 참일 경우에만 반복문 내부를 실행합니다.</li>
        <li>증감식은 반복문이 끝나고 증감식을 실행합니다. 일반적인 경우 일정 경우 조건식을 거짓으로 만들 수 있도록 설정합니다.</li>
      </ul>
      <pre class="line-numbers">
        <code class="language-java">for (int i = 0; i < 10; i++) {
            system.out.println(i);
        }</code>
    </pre>
      <p>해당 코드는
        <code>for</code>문의 가장 보편적인 사용법입니다.
        <code>i</code>는 0부터 1씩 커지며 9까지 출력할 것입니다.
      </p>
      <p>만약
        <code>n</code>번의 반복을 원한다면 다음과 같이
        <code>i</code>를 선언하고 0으로 초기화 한 후 변수가
        <code>n</code>보다 작다면
        <code>i</code>를 1씩 증감시키도록 합니다.
      </li>
      <li>while 문
        <p>
          <code>while</code>
          문은 조건식이 참인 동안 반복 실행합니다. 반복 횟수가 명확하지 않을 때 사용됩니다.</p>
        <p>
          <strong>구문</strong>
        </p>
        <pre class="line-numbers">
    <code class="language-java">while (조건식) {
        // 반복 실행할 코드
    }
    </code>
    </pre>
        <pre class="line-numbers">
    <code class="language-java">int i = 0;
        while (i < 10) {
            system.out.println(i);
            i++;
    }</code>
    </pre>
        <p>다음과 같이 i가 10보다 작을 경우에 while문 내부의 값을 실행하며 i의 값이 1씩 커지도록 변경합니다.</p>
      </li>
      <li>do-while 문
        <p>
          <code>do-while</code>
          문은 최소 한 번은 코드 블록을 실행하고, 그 후 조건식을 평가하여 반복을 계속할지 결정합니다.</p>
        <p>
          <strong>구문</strong>
        </p>
        <pre class="line-numbers">
    <code class="language-java">do {
        // 반복 실행할 코드
    } while (조건식);</code>
    </pre>
      </li>
    </ol>

    <h3>반복문의 중첩</h3>
    <p>반복문은 다른 반복문 안에 중첩하여 사용할 수 있습니다. 이를 통해 다차원 배열이나 복잡한 조건을 처리할 수 있습니다.</p>
    <pre class="line-numbers">
    <code class="language-java">for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            system.out.println("i: " + i + ", j: " + j);
        }
    }</code>
    </pre>
    <p>이 코드는 두 개의
      <code>for</code>
      문이 중첩되어 있어,
      <code>i</code>와
      <code>j</code>의 조합을 출력합니다.
    </p>

    <h3>반복문 제어</h3>
    <pre class="line-numbers">
    <code class="language-java">while (true) {
        // 반복 실행할 코드
    }</code>
    </pre>

    <p>다음 코드는 언제 멈출까요?
      <code>while(ture)</code>는 영원히 멈추지 않습니다. 영원히 말이죠! 이러한 문제를 대처하기 위해 반복문은 제어 명령어를 사용할 수 있습니다. 반복문 내에서
      <code>break</code>와
      <code>continue</code>
      키워드를 사용하여 제어 흐름을 변경할 수 있습니다.
    </p>
    <ul>
      <li>
        <strong>break</strong>: 현재 반복문을 즉시 종료합니다.</li>
      <li>
        <strong>continue</strong>: 현재 반복의 나머지 부분을 건너뛰고, 다음 반복을 시작합니다.</li>
    </ul>

    <pre class="line-numbers">
        <code class="language-java">for (int i = 0; i < 10; i++) {
            if (i == 5) {
                break; // i가 5일 때 반복문 종료
            }
            system.out.println(i);
        }</code>
    </pre>
    <p>헤당 코드는 i가 5일 때 반복문을 탈출할 수 있도록 제어합니다.
      <code>i</code>가 5와 같다면
      <code>break</code>
      명령어를 만나게 되고
      <strong>배열 밖</strong>으로 진행하게 됩니다.
    </p>

    <pre class="line-numbers">
        <code class="language-java">
        for (int i = 0; i < 10; i++) {
            if (i % 2 == 0) {
                continue; // 짝수일 때는 건너뜀
            }
            system.out.println(i);
        }</code>
    </pre>
    <p>
      <code>continue</code>를 활용한다면 원하는 조건에서 반복문 실행을 건너뛰고 다시 처음으로 돌아갈 수 있도록 할 수 있습니다.
      <code>break</code>와 차이점은 배열의 밖이 아니라 배열의 처음으로 돌아간다는 것입니다.</p>

    <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
      <h2>조건문</h2>
    </div>
    <p>자바 조건문은 특정 조건에 따라 코드의 실행 흐름을 제어하는 데 사용됩니다. 조건문을 사용하면 프로그램이 주어진 조건을 평가하고, 그 조건이 참일 때만 특정 코드를 실행하도록 할 수 있습니다. 자바에서 가장 기본적인 조건문은
      <code>if</code>,
      <code>if-else</code>,
      <code>else if</code>, 그리고
      <code>switch</code>
      문입니다.
    </p>

    <ol>
      <li>
        <code>if</code>
        문
        <p>
          <code>if</code>
          문은 조건이 참일 때만 블록 안의 코드를 실행합니다.</p>
        <pre class="line-numbers">
    <code class="language-java">int number = 10;
    if (number > 0) {
        system.out.println("number is positive.");
    }</code>
    </pre>
        <p>여기서
          <code>number &gt; 0</code>
          조건이 참이므로, "Number is positive."가 출력됩니다.
        </p>
      </li>

      <li>
        <code>if-else</code>
        문
        <p>
          <code>if-else</code>
          문은 조건이 참일 때는
          <code>if</code>
          블록을, 거짓일 때는
          <code>else</code>
          블록을 실행합니다.</p>
        <pre class="line-numbers">
    <code class="language-java">int number = -5;
    if (number > 0) {
        system.out.println("number is positive.");
    } else {
        system.out.println("number is not positive.");
    }</code>
    </pre>
        <p>여기서는
          <code>number &gt; 0</code>
          조건이 거짓이므로, "Number is not positive."가 출력됩니다.
        </p>
      </li>
      <li>
        <code>else if</code>
        문
        <p>여러 조건을 체크할 때는
          <code>else if</code>
          문을 사용합니다. 첫 번째 조건이 거짓이면 다음 조건을 체크합니다.
        </p>
        <pre class="line-numbers">
    <code class="language-java">int number = 0;
    if (number > 0) {
        system.out.println("number is positive.");
    } else if (number < 0) {
        system.out.println("number is negative.");
    } else {
        system.out.println("number is zero.");
    }</code>
    </pre>
        <p>여기서는
          <code>number</code>가 0이므로, 마지막
          <code>else</code>
          블록이 실행되어 "Number is zero."가 출력됩니다.
        </p>
      </li>
      <li>
        <code>switch</code>
        문
        <p>
          <code>switch</code>
          문은 하나의 변수 값에 따라 여러 경우(case)를 처리할 때 사용합니다. 각
          <code>case</code>는
          <code>break</code>
          문으로 끝나며,
          <code>break</code>
          문이 없으면 다음
          <code>case</code>로 실행이 넘어갑니다.</p>
        <pre class="line-numbers">
    <code class="language-java">int day = 3;
    switch (day) {
        case 1:
            system.out.println("monday");
            break;
        case 2:
            system.out.println("tuesday");
            break;
        case 3:
            system.out.println("wednesday");
            break;
        default:
            system.out.println("invalid day");
            break;
    }</code>
    </pre>
        <p>여기서는
          <code>day</code>가 3이므로 "Wednesday"가 출력됩니다.
        </p>
      </li>

    </ol>
    <p>조건문은 다양한 상황에서 사용될 수 있습니다. 예를 들어 사용자 입력을 검증하거나, 특정 조건에 따라 다른 동작을 수행하도록 할 때 유용합니다.</p>
  </div>
</div>
<!-- Static -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>Static</h1>
  </div>
  <p>변수의 복사에 대해 설명하며 Static 변수가 메소드 영역에 저장된다는 설명을 드렸습니다. 따라서 프로그램 시작과 동시에 생성되고 프로그램이 종료될 때 까지 유지됩니다. 특정 클래스의 인스턴스들이 공통적으로 사용할 수 있습니다. 즉
    <strong>static 키워드는 클래스 멤버(변수와 메소드)에 사용되어 그 멤버가 클래스 레벨에서 접근 가능하게 만듭니다.</strong>
    이는 객체 인스턴스가 아닌 클래스 자체에 속하게 됩니다.
  </p>

  <ol>
    <li>정적 변수 (Static Variable)
      <p>정적 변수는 클래스에 하나만 존재하며, 모든 인스턴스가 공유합니다.</p>
      <ul>
        <li>클래스 로딩 시 메모리에 할당됩니다.</li>
        <li>모든 인스턴스가 동일한 값을 공유합니다.</li>
        <li>인스턴스 생성 없이 클래스명으로 직접 접근할 수 있습니다.</li>
      </ul>
      <pre class="line-numbers">
	<code class="language-java">public class example {
	    public static int staticvar = 0;
	
	    public void increment() {
	        staticvar++;
	    }
	
	    public static void main(string[] args) {
	        example obj1 = new example();
	        example obj2 = new example();
	        
	        obj1.increment();
	        obj2.increment();
	        
	        system.out.println(example.staticvar); // 출력: 2
	    }
	}</code>
			</pre>
    </li>
    <li>정적 메소드 (Static Method)
      <p>정적 메소드는 인스턴스와 무관하게 클래스에 속하며, 정적 변수에 접근하거나 정적 메소드를 호출할 때 사용됩니다.</p>
      <ul>
        <li>인스턴스 변수나 인스턴스 메소드를 직접 사용할 수 없습니다.</li>
        <li>클래스명으로 직접 호출할 수 있습니다.</li>
      </ul>
      <pre class="line-numbers">
	<code class="language-java">public class mathutils {
	    public static int add(int a, int b) {
	        return a + b;
	    }
	
	    public static void main(string[] args) {
	        int sum = mathutils.add(5, 3);
	        system.out.println(sum); // 출력: 8
	    }
       }</code>
			</pre>
    </li>
    <li>정적 블록 (Static Block)
      <p>정적 블록은 클래스가 메모리에 로드될 때 한 번 실행되며, 주로 정적 변수를 초기화하는 데 사용됩니다.</p>
      <pre class="line-numbers">
	<code class="language-java">public class staticblockexample {
	    public static int staticvar;
	
	    static {
	        staticvar = 10;
	        system.out.println("static block executed.");
	    }
	
	    public static void main(string[] args) {
	        system.out.println(staticblockexample.staticvar); // 출력: 10
	    }
	}</code>
			</pre>
    </li>
    <li>정적 내부 클래스 (Static Nested Class)
      <p>정적 내부 클래스는 외부 클래스의 인스턴스와 무관하게 동작할 수 있습니다.</p>
      <pre class="line-numbers">
	<code class="language-java">public class outerclass {
	    static class innerclass {
	        void display() {
	            system.out.println("static inner class");
	        }
	    }
	
	    public static void main(string[] args) {
	        outerclass.innerclass inner = new outerclass.innerclass();
	        inner.display(); // 출력: static inner class
	    }
	}</code>
			</pre>
    </li>
  </ol>
  <code></code>
  <p>
    <code>static</code>은 편리하지만 메모리에 계속 남아있습니다. 따라서
    <code>static</code>의 너무 많은 사용은 프로그램 메모리 사용량을 증가시키고 자주 사용하지 않을 경우 메모리 누수의 원인이 될 수 있습니다.</p>
</div>

<!-- 예외처리 -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>오류와 예외처리</h1>
  </div>
  <img src="resources/img/error.png" style="max-height: 50vh;">
  <p>프로그래머에게 오류는 가장 싫지만 동시에 가장 필요한 요소입니다. 모든 내용을 단 한번에 오류없이 작성할 수 있다면 좋겠지만 그럴수는 없죠. 끊임없이 오류를 만나고 그 원인을 파악하는 과정은 필수적인 사항입니다.</p>
  <p>자바에서도 오류는 계속 나타납니다. 이러한 오류는 다양한 원인에 의해 나타납니다. 우리가 해야 할 일은 이러한 오류를 잘 파악하고 그에 대처하는 방법입니다. 이번엔 오류와 예외처리에 대해 알아봅시다.</p>

  <ol>
    <li>
      <strong>오류 (Error)</strong>
      <p>
        <strong>오류(Error)</strong>는 주로 JVM(Java Virtual Machine)에서 발생하며, 시스템 수준의 심각한 문제를 나타냅니다. 일반적으로 이러한 오류는 애플리케이션 레벨에서 잡아서 처리할 수 없습니다. 대부분의 경우, 오류는 프로그램의 비정상 종료를 초래하며, 개발자가 이를 직접 처리하려고 시도하기보다는, 오류를 방지할 수 있는 방법을 찾아야 합니다. 대표적인 오류들에는 이러한것들이 있습니다.</p>
      <ul>
        <li>
          <code>StackOverflowError</code>: 무한 재귀 호출로 인해 스택이 넘치는 경우 발생.
          <div class="col">
            <div>
              <pre class="line-numbers">
<code class="language-java">public class errorexample {
public static void main(string[] args) {
 causestackoverflowerror();
}

public static void causestackoverflowerror() {
    causestackoverflowerror();
}        
}</code>
        </pre>
            </div>
            <div>
              <img src="resources/img/stackoverflowerror.png">
            </div>
          </div>
        </li>
        <li>
          <code>OutOfMemoryError</code>: JVM이 더 이상 메모리를 할당할 수 없는 경우 발생.</li>
      </ul>
    </li>

    <li>
      <strong>예외 (Exception)</strong>
      <p>
        <strong>예외(Exception)</strong>는 프로그램에서 발생할 수 있는 문제를 나타내며, 대부분의 예외는 개발자가 적절히 처리할 수 있습니다. 예외는 다시
        <strong>체크 예외(Checked Exception)</strong>와
        <strong>언체크 예외(Unchecked Exception)</strong>로 나뉩니다.</p>

      <ul>
        <li>
          <strong>체크 예외 (Checked Exception)</strong>
          <p>체크 예외는 컴파일 시점에 반드시 처리해야 하는 예외입니다. 주로 외부 환경(파일, 네트워크 등)과의 상호작용에서 발생하는 예외가 해당됩니다.</p>

          <ul>
            <li>
              <code>IOException</code>: 파일 읽기/쓰기 중 발생하는 예외.
              <div class="col">
                <div>
                  <pre class="line-numbers">
<code class="language-java">import java.io.filereader;
import java.io.ioexception;

public class checkedexceptionexample {
public static void main(string[] args) {
    try {
        filereader file = new filereader("nonexistentfile.txt");
    } catch (ioexception e) {
        system.out.println("파일을 읽을 수 없습니다: " + e.getmessage());
    }
}
}</code>
        </pre>
                </div>
                <div>
                  <img src="resources/img/ioexceptionerror.png">
                </div>
              </div>
            </li>
            <li>
              <code>SQLException</code>: 데이터베이스 작업 중 발생하는 예외.</li>
          </ul>
        </li>

        <li>
          <strong>언체크 예외 (Unchecked Exception)</strong>
          <p>언체크 예외는 런타임 시점에 발생하며, 개발자가 반드시 처리하지 않아도 되는 예외입니다. 주로 프로그래머의 실수로 인해 발생하는 경우가 많습니다.</p>
          <ul>
            <li>
              <code>NullPointerException</code>: null 참조를 역참조할 때 발생.</li>
            <li>
              <code>ArrayIndexOutOfBoundsException</code>: 배열의 잘못된 인덱스를 참조할 때 발생.
              <div class="col">
                <div>
                  <pre class="line-numbers">
<code class="language-java">public class uncheckedexceptionexample {
public static void main(string[] args) {
    string str = null;
    try {
        system.out.println(str.length());
    } catch (nullpointerexception e) {
        system.out.println("null 객체의 메서드를 호출했습니다: " + e.getmessage());
    }
}
}</code>
        </pre>
                </div>
                <div>
                  <img src="resources/img/nullerror.png">
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li>
        <strong>예외 처리 키워드</strong>

        <ul>
          <li>
            <strong>try-catch</strong>
            <p>예외가 발생할 가능성이 있는 코드를
              <code>try</code>
              블록에 작성하고, 예외가 발생했을 때의 처리를
              <code>catch</code>
              블록에 작성합니다.
            </p>
            <pre class="line-numbers">
<code class="language-java">try {
// 예외가 발생할 가능성이 있는 코드
} catch (exceptiontype e) {
// 예외 처리 코드
}</code>
                </pre>
          </li>

          <li>
            <strong>finally</strong>
            <p>
              <code>finally</code>
              블록은 예외 발생 여부와 관계없이 항상 실행됩니다. 주로 자원 해제 코드를 작성할 때 사용됩니다.</p>
            <pre class="line-numbers">
<code class="language-java">try {
// 예외가 발생할 가능성이 있는 코드
} catch (exceptiontype e) {
// 예외 처리 코드
} finally {
// 항상 실행되는 코드
}</code>
                </pre>
          </li>

          <li>
            <strong>throw</strong>
            <p>직접 예외를 발생시킬 때 사용합니다.</p>
            <pre class="line-numbers">
<code class="language-java">public void checkage(int age) {
if (age < 18) {
    throw new illegalargumentexception("나이는 18세 이상이어야 합니다.");
}
}</code>
                </pre>
          </li>

          <li>
            <strong>throws</strong>
            <p>메서드가 처리하지 않고 호출한 쪽으로 예외를 전달할 때 사용합니다.</p>
            <pre class="line-numbers">
<code class="language-java">public void readfile(string filename) throws ioexception {
filereader file = new filereader(filename);
}</code>
                </pre>
          </li>
        </ul>
      </li>

      <li>
        <strong>사용자 정의 예외</strong>
        <p>개발자는 필요에 따라 사용자 정의 예외를 만들 수 있습니다. 사용자 정의 예외는
          <code>Exception</code>
          클래스를 상속받아 정의합니다.
        </p>
        <pre class="line-numbers">
<code class="language-java">class myexception extends exception {
public myexception(string message) {
    super(message);
}
}

public class main {
public static void main(string[] args) {
    try {
        throw new myexception("사용자 정의 예외 발생");
    } catch (myexception e) {
        system.out.println("예외 처리: " + e.getmessage());
    }
}
}</code>
        </pre>
      </li>

      <li>
        <strong>예외 처리 주의 사항</strong>
        <ul>
          <li>
            <strong>적절한 예외 처리</strong>: 가능한 한 구체적인 예외를 잡아서 처리합니다.</li>
          <li>
            <strong>예외 정보 기록</strong>: 예외 발생 시 로그를 남겨서 문제를 추적할 수 있도록 합니다.</li>
          <li>
            <strong>자원 해제</strong>:
            <code>finally</code>
            블록을 사용하여 파일, 네트워크 연결 등 자원을 적절히 해제합니다.</li>
          <li>
            <strong>사용자 정의 예외</strong>: 의미 있는 예외를 정의하여 특정 상황에 맞는 예외 처리를 합니다.</li>
        </ul>
        <p>자바의 예외처리 메커니즘을 잘 활용하면 프로그램의 안정성을 높이고, 예상치 못한 상황에서도 적절히 대응할 수 있습니다.</p>
      </li>
    </ol>
  </div>

<!-- 입력 / 출력 -->
<div>
  
	<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
		<h1>입출력</h1>
	</div>

	<p>자바에서 입력과 출력(Input and Output, I/O)은 데이터의 읽기와 쓰기를 의미합니다. 자바는 다양한 I/O 작업을 지원하며, 이를 위해 <code>java.io</code> 패키지를 주로 사용합니다. 여기서는 콘솔 입력/출력, 파일 입력/출력, 그리고 네트워크 입력/출력에 대해 설명하겠습니다.
	</p>


	<h3>1. 콘솔 입력/출력</h3>
	<ol>
		<li>콘솔 입력
			<p>콘솔에서 사용자로부터 입력을 받기 위해 <code>Scanner</code> 클래스를 사용할 수 있습니다. <code>Scanner</code> 클래스는 <code>java.util</code> 패키지에 포함되어 있습니다.
		</p> <pre class="line-numbers">
    <code class="language-java">import java.util.Scanner;
    
    public class ConsoleInputExample {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter your name: ");
            String name = scanner.nextLine();
            System.out.println("Hello, " + name + "!");
            scanner.close();
        }
    }</code>
    </pre>
		</li>
		<li>콘솔 출력
			<p>콘솔에 출력하기 위해 <code>System.out.println()</code> 메서드를 사용할 수 있습니다. 이 메서드는 인수를 출력한 후 줄바꿈을 추가합니다.
		</p> <pre class="line-numbers">
     <code class="language-java">public class ConsoleOutputExample {
         public static void main(String[] args) {
             System.out.println("Hello, world!");
         }
     }</code>
    </pre>
		</li>

	</ol>
	<h3>2. 파일 입력/출력</h3>
	<ol>
		<li>파일 입력
			<p>파일로부터 데이터를 읽기 위해 <code>FileReader</code>와 <code>BufferedReader</code> 클래스를 사용할 수 있습니다.
		</p> <pre class="line-numbers">
    <code class="language-java">import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;
    
    public class FileInputExample {
        public static void main(String[] args) {
            try (BufferedReader reader = new BufferedReader(new FileReader("input.txt"))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }</code>
    </pre>
		</li>
		<li>파일 출력
			<p>파일에 데이터를 쓰기 위해 <code>FileWriter</code>와 <code>BufferedWriter</code> 클래스를 사용할 수 있습니다.
		</p> <pre class="line-numbers">
    <code class="language-java">import java.io.BufferedWriter;
            import java.io.FileWriter;
            import java.io.IOException;
            
            public class FileOutputExample {
                public static void main(String[] args) {
                    try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
                        writer.write("Hello,file!");
                writer.newLine();
                writer.write("This is a second line.");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }</code>
    </pre>
		</li>
	</ol>

	<h3>3. 네트워크 입력/출력</h3>
	<p>자바에서는 <code>java.net</code> 패키지를 사용하여 네트워크를 통한 I/O를 수행할 수 있습니다. 여기서는 간단한 클라이언트-서버 예제를 통해 네트워크 I/O를 설명하겠습니다.
	</p>
	<ol>
		<li>서버
			<p>서버는 특정 포트에서 클라이언트의 연결을 기다립니다.</p> <pre class="line-numbers">
        <code class="language-java">import java.io.*;
        import java.net.*;
        
        public class Server {
            public static void main(String[] args) {
                try (ServerSocket serverSocket = new ServerSocket(12345)) {
                    System.out.println("Server is listening on port 12345");
                    Socket socket = serverSocket.accept();
                    System.out.println("Client connected");
        
                    BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    PrintWriter output = new PrintWriter(socket.getOutputStream(), true);
        
                    String message = input.readLine();
                    System.out.println("Received: " + message);
                    output.println("Hello, client!");
        
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }</code>
    </pre>

			<p>위 예제에서는 서버가 포트 12345에서 클라이언트의 연결을 기다리고, 클라이언트로부터 메시지를 받아 응답을 보냅니다.</p>
		</li>
		<li>클라이언트
			<p>클라이언트는 서버에 연결하고 메시지를 보냅니다.</p> <pre class="line-numbers">
        <code class="language-java">import java.io.*;
        import java.net.*;
        
        public class Client {
            public static void main(String[] args) {
                try (Socket socket = new Socket("localhost", 12345)) {
                    PrintWriter output = new PrintWriter(socket.getOutputStream(), true);
                    BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        
                    output.println("Hello, server!");
                    String response = input.readLine();
                    System.out.println("Received: " + response);
        
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }</code>
    </pre>
			<p>위 예제에서는 클라이언트가 서버에 연결하고 메시지를 보낸 후, 서버의 응답을 받아 출력합니다.</p>
		</li>
	</ol>
	<p>자바에서 입력과 출력은 매우 중요한 기능이며, 콘솔, 파일, 네트워크 등 다양한 방식으로 데이터를 주고받을 수 있습니다. 각 상황에 맞는 I/O 클래스를 적절히 사용하여 프로그램의 데이터 처리 기능을 구현할 수 있습니다.</p>


</div>