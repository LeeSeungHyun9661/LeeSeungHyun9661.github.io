<!-- 기초 문법 -->
<div class="hstack gap-0" style="background-color: #dee2e6;">
  <div class="p-2 ms-auto" style="font-size: 15px;">
    <strong>편집 일자</strong>: 2024년 6월 
  </div>
</div>

<!-- 메서드 -->
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 mb-3 border-bottom">
  <h2 class="post-title">메서드</h2>
</div>
<p>메서드는 특정 기능을 수행하기 위한 코드 블록입니다. 코드의 처리 과정에서 반복적으로 실행해야 하는 부분이나 분리하여 처리해야하는 부분을 위해서 메서드를 정의하고 사용합니다. 메서드는 다음과 같은 구성 요소로 이루어져 있습니다.</p>

<pre class="line-numbers"><code class="language-java">반환형 메서드명(매개변수) {
      // 메서드 몸체
}</code></pre>
<table class="table" cellspacing="0" style="font-size: 13px;">
  <tbody>
    <tr>
      <td>
        <strong>반환형</strong>
      </td>
      <td>메서드가 반환하는 값의 데이터 타입을 명시합니다. 반환값이 없을 경우<code>void</code>를 사용합니다.</td>
    </tr>
    <tr>
      <td>
        <strong>메서드명</strong>
      </td>
      <td>메서드의 이름을 정의합니다. 보통 소문자로 시작하고 동사 형태를 사용합니다.</td>
    </tr>
    <tr>
      <td>
        <strong>매개변수</strong>
      </td>
      <td>메서드가 입력받을 값들을 정의합니다. 각 매개변수는 데이터 타입과 변수명으로 이루어집니다.</td>
    </tr>
    <tr>
      <td>
        <strong>메서드 몸체</strong>
      </td>
      <td>메서드가 수행할 작업을 정의하는 코드 블록입니다.</td>
    </tr>
  </tbody>
</table>

<p>자바에서 메서드를 정의하는 예제입니다</p>
<pre class="line-numbers"><code class="language-java">public class myclass {
  // 인스턴스 메서드
  public void instancemethod() {
      system.out.println("this is an instance method.");
  }

  // 정적 메서드
  public static void staticmethod() {
      system.out.println("this is a static method.");
  }
}</code></pre>
<p>메서드는 Static을 추가하여 인스턴스 메서드를 정적(static) 메서드로 사용할 수 있습니다. 인스턴스는 메서드는 객체의 인스턴스에 속하기 때문에 객체를 생성해야 사용할 수 있습니다. 반면에 Static 메서드는 클래스에 속하기 때문에 Method 영역에 저장됩니다. 즉 객체 생성 없이 사용할 수 있습니다.
</p>

<!-- 배열 -->
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 mb-3 border-bottom">
  <h2 class="post-title">배열</h2>
</div>
<p>배열(Array)은 동일한 타입의 여러 개의 값을 하나의 변수로 관리할 수 있는 자료구조입니다. 배열은 메모리상 연속적으로 저장되어 있어 접근이 빠르고 인덱스를 통해 각 요소로 접근할 수 있습니다.</p>
<table class="table" cellspacing="0" style="font-size: 13px;">
  <tbody>
    <tr>
      <td>
        <strong>배열 선언</strong>
        <p>배열을 선언할 때는 배열의 타입과 이름을 지정합니다. 선언하는 방법은 다음과 같습니다.</p>
        <pre class="line-numbers"><code class="language-java">int[] numbers;
string[] names;</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <strong>배열 생성</strong>
        <p>배열을 생성할 때는
          <code>new</code>
          연산자를 사용하며 배열의 크기를 지정해야 합니다. 이를 통해 특정 길이의 빈 배열이 생성됩니다.</p>
        <pre class="line-numbers"><code class="language-java">numbers = new int[5];
names = new string[10];</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <strong>배열 초기화</strong>
        <p>배열을 선언하고 생성하면서 동시에 초기화할 수 있습니다. 이 경우 길이를 지정하지 않으면 초기값의 길이로 배열의 길이가 설정됩니다.</p>
        <pre class="line-numbers"><code class="language-java">int[] numbers = {1, 2, 3, 4, 5};
string[] names = {"alice", "bob", "charlie", "david", "eve"};</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <strong>배열의 길이</strong>
        <p>배열의 길이는
          <code>length</code>속성을 사용하여 얻을 수 있습니다:
        </p>
        <pre class="line-numbers"><code class="language-java">int length = numbers.length;</code></pre>
      </td>
    </tr>
  </tbody>
</table>

<p>자바 배열의 선언, 생성, 초기화, 그리고 요소 접근을 보여주는 간단한 예제로 확인해봅시다.</p>
<pre class="line-numbers"><code class="language-java">public class arrayexample {
  public static void main(string[] args) {
      // 정수 배열 선언 및 생성
      int[] numbers = new int[5];

      // 배열 초기화
      numbers[0] = 10;
      numbers[1] = 20;
      numbers[2] = 30;
      numbers[3] = 40;
      numbers[4] = 50;

      // 배열 요소 접근
      for (int i = 0; i < numbers.length; i++) {
          system.out.println("element at index " + i + ": " + numbers[i]);
      }
      /*
       * 0: 10
       * 1: 20
       * 2: 30
       * 3: 40
       * 4: 50
      */

      // 문자열 배열 선언 및 초기화
      string[] names = {"alice", "bob", "charlie"};

      // 배열 요소 접근
      for (int i = 0; i < names.length; i++) {
          system.out.println("name at index " + i + ": " + names[i]);
      }
      /*
       * 0: alice
       * 1: bob
       * 2: charlie
      */
  }
}</code></pre>

<h4 style="font-weight: bold;">배열의 고정 길이</h4>
<p>배열의 크기는 생성 시에 결정되며, 이후 변경할 수 없습니다. 배열 크기 이상의 요소로 접근할려고 하면
  <code>ArrayIndexOutOfBoundsException</code>
  오류가 반환됩니다. 따라서 더 큰 배열을 선언하여 그 값을 옮겨주는 것으로 배열의 크기를 늘리는 방법을 활용할 수도 있습니다.</p>
<pre class="line-numbers"><code class="language-java">//배열의 범위를 벗어날 경우 더 큰 배열을 선언하는 함수
public static int[] addelement(int[] array, int index, int value) {
  
  if (index >= array.length) { // index가 배열의 범위를 벗어날 경우
    // 새로운 배열 생성 (현재 배열 크기 + 1)
    int[] newarray = new int[array.length + 1];

    // 기존 배열의 내용을 새 배열로 복사
    system.arraycopy(array, 0, newarray, 0, array.length);  

    // 새 배열의 마지막 인덱스에 값 추가
    newarray[newarray.length - 1] = value;

    return newarray;
  } else { // index가 배열의 범위안에 있을 경우

    // index 위치에 값을 저장합니다.
    array[index] = value;

    return array;
  }
}</code></pre>

<!-- 배열 -->
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 mb-3 border-bottom">
  <h2 class="post-title">깊은 복사 / 얕은 복사 (Deep Copy / Shallow Copy)</h2>
</div>
<p>간단한 코드를 한번 살펴보도록 합시다.</p>
<pre class="line-numbers"><code class="language-java">public class main { 

  static int snum = 10;

  public static void main(string[] args) {
      int num = 1; // 기본 타입 변수
      int[] arr = { 1 }; // 참조 타입 변수

      f1(num); 
      f2(arr);

      system.out.println("num :" + num);
      system.out.println("arr[0] :" + arr[0]);
  }

  static void f1(int num) {
      num += 1;
  }

  static void f2(int[] arr) {
      arr[0] += 1;
  }
}</code></pre>
<p>어떤 결과가 나타날까요?
  <code>num</code>의 경우
  <code>f1()</code>메서드에 의해 그 값이 호출됩니다. 1을 더해줬지만 출력 값은 변하지 않습니다. 하지만 배열의 경우 2가 출력됩니다.
  <code>f2()</code>
  메서드에 의해 그 값이 변경되었습니다. 이는 기본형과 참조형 변수의 저장 공간 활용에 따라 나타나는 차이점입니다.<strong>깊은 복사(Deep Copy)</strong>와
  <strong>얕은 복사(Shallow Copy)</strong>로 나타나는 두 차이점에 대해 알아봅시다.
</p>
<p>작성된 코드가 실행되면 컴파일 과정에서 자바 가상 머신(JVM)의 내부 메모리 영역에 변수가 저장되는데 그 종류에 따라 세 영역에 나누어 저장됩니다.</p>
<table class="table" cellspacing="0" style="font-size: 13px;">
  <tbody>
    <tr>
      <td>
        <strong>Method(Static) 영역</strong>
      </td>
      <td>클래스와 클래스 변수(Static 변수), 메소드가 저장됩니다.</td>
    </tr>
    <tr>
      <td>
        <strong>
          Stack 영역</strong>
      </td>
      <td>기본형 변수(Primitive Types)가 저장됩니다. 지역변수와 매개변수가 여기에 해당합니다.</td>
    </tr>
    <tr>
      <td>
        <strong>
          Heap 영역</strong>
      </td>
      <td>참조형 변수(Reference Type)가 저장됩니다. 데이터 타입을 가지는 객체(인스턴스), 배열이 여기에 저장됩니다.</td>
    </tr>
  </tbody>
</table>

<p>코드의 흐름과 영역에 저장되는 위치를 확인해보도록 합시다.</p>
<div class="row">
  <img class="col-6" src="/assets/img/copy_1.png">
  <img class="col-6" src="/assets/img/ex1.png">
</div>
<p>다음과 같은 코드가 실행되면 먼저 각 클래스, static 변수, 메서드가 Method 영역에 저장됩니다.</p>

<div class="row">
  <img class="col-6" src="/assets/img/copy_2.png">
  <img class="col-6" src="/assets/img/ex2.png">
</div>
<p>main 메서드가 실행되면 stack 영역에 값이 저장됩니다. 중요한 점은 참조형 변수입니다. 기본형 변수인
  <code>int</code>는 값 그 자체를 저장합니다. 하지만 참조형 변수인
  <code>int[]</code>(배열)은 그 주소값을 저장합니다. 배열 내부에 값은 Heap 영역에 저장되죠. 주소값은 그 장소를 가리키게 됩니다.
</p>
<div class="row">
  <img class="col-6" src="/assets/img/copy_3.png">
  <img class="col-6" src="/assets/img/ex3.png">
</div>
<p>먼저 함수
  <code>f1()</code>이 실행되면 Stack 영역에 새로운 Stack 프레임 영역이 만들어집니다. 매개변수의
  <code>num</code>은 다른 위치에 해당합니다. 값만 가져오게 되는 것이죠. 때문에 Stack 프레임 내부 값이 변경되어도 메서드 종료와 함께 사라지며 main의
  <code>num</code>은 아무 영향도 받지 않게 되는 것입니다.
</p>

<div class="row">
  <img class="col-6" src="/assets/img/copy_4.png">
  <img class="col-6" src="/assets/img/ex4.png">
</div>
<p>반면에
  <code>f2()</code>의 경우 Stack 프레임 영역에서 만들어진
  <code>arr</code>값은 같은 주소값을 가져오게 됩니다. 여전히 배열의 값이 저장된 Heap 영역을 가리키게 됩니다. 따라서 같은 주소값을 가리키는 변수는 영향을 끼치게 됩니다.
  <code>arr</code>의 값이 변경에 영향을 받게 됩니다.
</p>

<pre class="line-numbers"><code class="language-java">import java.util.arrays;

public class main {     
    public static void main(string[] args) {

        int num1 = 1;
        int num2 = num1;
        num1 += 1;
        system.out.println("num1 :" + num1 + " / num2:" + num2);

        int[] arr1 = { 1, 2, 3, 4 };
        int[] arr2 = arr1;

        arr1[0] = 7;
        arr2[3] = 9;

        system.out.println("arr1 :" + arrays.tostring(arr1));
        system.out.println("arr2 :" + arrays.tostring(arr2));
    }
}</code></pre>

<p>다음 코드의 결과를 예측할 수 있을까요? 기본형 변수
  <code>num1</code>은 1로 값이 초기화 되었습니다.
  <code>num2</code>또한 선언되는데 이 값은 num1의 값을 복사하게 됩니다. 두 값은 개별 위치에 저장되기 때문에 하나의 값이 변경되어도 다른 값은 영향을 받지 않습니다.
</p>
<p>하지만 참조형 변수
  <code>arr1</code>은 주소값을 가지고 있으며 배열을 가르키고 있습니다.
  <code>arr2</code>의 선언과
  <code>arr1</code>의 복제는 배열의 내용이 아니라 그 주소값을 복제하게 됩니다. 따라서
  <code>arr1</code>과
  <code>arr2</code>에 대한 값 변경은 동일한 주소값이 가리키는 원본에 적용되게 됩니다. 여기까지의 개념을
  <strong>얕은 복사(Shallow Copy)</strong>라고 합니다.
</p>
<p>그렇다면 배열은 복제할 수 없는 것일까요? 아닙니다. 개별의 주소값으로 배열을 선언하고 각 원소를 복제하는 방법으로 서로 영향받지 않는 동일한 내용의 배열을 생성할 수 있습니다.
  <strong>깊은 복사(Deep Copy)</strong>라 불리는 방법은 다음과 같이 구현이 가능합니다.
</p>

<table class="table" cellspacing="0" style="font-size: 13px;">
  <tbody>
    <tr>
      <td>
        <strong>
          <code>for</code>문을 통한 원소 복제</strong>
        <p>가장 단순한 방법으로 동일한 길이의 배열을 만들고
          <code>for</code>문을 통해 배열 원소값을 불러와 복제하는 방법입니다.</p>
        <pre class="line-numbers"><code class="language-java">int[] arr1 = { 1, 2, 3, 4 };
int[] arr2 = new int[4];

for (int i = 0; i < arr1.length; i++) {
    arr2[i] = arr1[i];
}</code></pre>
      </td>
    </tr>

    <tr>
      <td>
        <code>clone()</code>
        <p>특별한 매개변수 없이 짧고 간단하게 배열을 복제할 수 있습니다.</p>
        <pre class="line-numbers"><code class="language-java">int[] arr1 = { 1, 2, 3, 4 };
int[] arr2 = arr1.clone();</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <code>Arrays.copyOf()</code>
        <p>대상 배열에 특정 길이만큼 복제할 수 있습니다.</p>
        <pre class="line-numbers"><code class="language-java">int[] arr1 = { 1, 2, 3, 4 }; 
int[] arr2 = arrays.copyof(arr1, arr1.length);</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <code>System.arraycopy()</code>
        <p>배열의 복제 부분을 세세하게 조정할 수 있는 명령어입니다.</p>
        <pre class="line-numbers"><code class="language-java">int[] arr1 = { 1, 2, 3, 4 };
int[] arr2 = new int[4];
//(원본 배열, 원본 시작점, 대상 배열, 대상 시작점, 북제 길이)
system.arraycopy(arr1, 0, arr2, 0, arr1.length);</code></pre>
      </td>
    </tr>
  </tbody>
</table>
