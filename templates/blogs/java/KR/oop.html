<!-- 객체지향-->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>객체지향 언어의 특징</h1>
  </div>

  <p>자바는
    <strong>'객체 지향 프로그래밍 언어'</strong>입니다.
    <strong>객체(object)</strong>는 자바 언어의 모든 인스턴스의 기반이 됩니다. 세상에 존재하는 것은 모두 객체에 해당합니다. 클래스는 이러한 객체를 잡아줄 수 있는 틀을 의미합니다. 클래스와 객체에 대한 개념과 이를 기반으로 하는 자바의 '객체 지향적' 성격은 프로그래밍 언어를 이해하는데 핵심적인 역할을 합니다.
  </p>

  <p>객체 지향 언어의 네 가지 특징은 다음과 같습니다.</p>
  <div class="row">
    <img class="col-6" src="resources/img/oopfeature.png">
    <ol class="col-6">
      <li>
        <strong>상속(Inheritance)</strong>
        <p>객체지향 언어는 새로운 클래스가 기존의 클래스를 기반으로 만들어질 수 있게 합니다. 이를 통해 코드 재사용성을 높이고, 계층 구조를 통해 클래스 간의 관계를 정의할 수 있습니다. 자식 클래스는 부모 클래스의 속성과 메소드를 상속받아 사용할 수 있으며, 필요에 따라 이를 확장하거나 수정할 수 있습니다.</p>
      </li>
      <li>
        <strong>캡슐화(Encapsulation)</strong>
        <p>객체지향 언어는 데이터와 데이터를 처리하는 메소드를 하나의 객체로 묶어 관리합니다. 이를 통해 데이터의 접근을 제한하고, 객체의 내부 상태를 외부에서 직접 접근하지 못하도록 보호합니다. 이는 정보 은닉(Information Hiding)이라고도 불리며, 객체 간의 상호 작용은 공개된 메소드를 통해서만 이루어집니다.</p>
      </li>
      <li>
        <strong>다형성(Polymorphism)</strong>
        <p>다형성은 동일한 인터페이스를 통해 서로 다른 데이터 타입을 처리할 수 있는 능력을 의미합니다. 객체지향 언어에서는 주로 메소드 오버로딩(Method Overloading)과 메소드 오버라이딩(Method Overriding)을 통해 다형성을 구현합니다. 이는 동일한 메소드 이름이 상황에 따라 다른 동작을 하도록 할 수 있게 해줍니다.</p>
      </li>
      <li>
        <strong>추상화(Abstraction)</strong>
        <p>추상화는 복잡한 시스템으로부터 불필요한 세부 사항을 숨기고, 중요한 부분만을 노출하여 간단하게 만드는 개념입니다. 객체지향 언어에서는 추상 클래스(Abstract Class)와 인터페이스(Interface)를 통해 추상화를 구현할 수 있습니다. 이를 통해 구현 세부 사항을 숨기고, 구현 객체 간의 상호 작용을 단순화할 수 있습니다.</p>
      </li>
    </ol>
  </div>
  <p>복잡한 내용입니다. 하지만 이러한 내용을 하나하나 살펴보게 된다면 자바가 얼마나 유용하고 견고한 언어인지 알게될 것입니다.</p>

</div>
<!-- 클래스 -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>클래스</h1>
  </div>
  <p>여기 차량에 대한 정보가 있습니다. 네 대의 차량이 존재하며 이름, 차종, 제조사, 가격과 같은 성격을 가지고 있습니다.</p>
  <div class="row">
    <div class="col-6">
      <pre class="line-numbers">
    <code class="language-java">string car1_name = "a";
    string car1_type = "van";
    string car1_company = "acompany";
    int car1_price = 150;

    string car2_name = "b";
    string car2_type = "sedan";
    string car2_company = "bcompany";
    int car2_price = 200;

    string car3_name = "c";
    string car3_type = "truck";
    string car3_company = "acompany";
    int car3_price = 100;

    string car4_name = "d";
    string car4_type = "sedan";
    string car4_company = "ccompany";
    int car4_price = 180;</code>
    </pre>
    </div>
    <img class="col-6" src="resources/img/4car.png">
  </div>

  <p>각각의 차량에 대해 개별적인 변수를 선언할 수 있습니다. 네? 100대의 차량이요? 그럼 100번 추가하면 됩니다. 네? 20만대요? 맙소사 다른 방법을 찾아야 합니다. 하나의 대상에 대한 변수를 효율적으로 관리할 수 있는
    <strong>틀</strong>이 필요합니다.
  </p>

  <ol>
    <li>
      <strong>클래스 생성</strong>
      <p>클래스의 기본 구조는 다음과 같습니다.</p>
      <pre class="line-numbers">
    <code class="language-java">public class classname {
	    // 필드 (멤버 변수)
	    datatype fieldname;
	
	    // 메서드
	    returntype methodname(parameters) {
	        // 메서드 몸체
	    }
	}</code>
    </pre>
      <p>이번엔 클래스를 통해 차량에 대한 틀을 만들고 이를 기반으로 인스턴스를 선언해봅시다.</p>
      <pre class="line-numbers">
    <code class="language-java">class car {
        string name;
        string type;
        string company;
        int price;
    }
    
    public class main {
        public static void main(string[] args) {
            car car1 = new car();
        }

    }</code>
    </pre>
    </li>
    <li>
      <strong>클래스 생성자</strong>
      <p>클래스는 인스턴스로써 생성될 때 초기 변수와 행동을 지정할 수 있습니다. 이는 클래스의 생성자를 통해 구현됩니다. 클래스는 기본생성자를 가지고 있으며 구조는
        <code>
          클래스이름(){}</code>로 설정되어 있습니다. 이는 아무 매개변수도 받지 않음을 의미합니다. 그렇다면
        <code>Car</code>
        클래스가 생성자로 초기 값을 받을 수 있도록 만들어봅시다.
      </p>
      <pre class="line-numbers">
    <code class="language-java">class car {
	    string name;
	    string type;
	    string company;
	    int price;
	
	    public car(string name, string type, string company, int price) { // 생성자
	        this.name = name;
	        this.type = type;
	        this.company = company;
	        this.price = price;
	
	    }
	}
    
    public class main {
        public static void main(string[] args) {
            car car1 = new car("a", "van", "acompany", 150); // 객체 선언과 동시에 생성자를 통해 클래스 변수 선언;
        }

    }</code>
    </pre>
      <p>
        <code>Car</code>
        클래스는 인스턴스로 생성될 때 생성자와 같이 매개변수를 전달 받습니다. 전달받은 매개변수는 클래스 변수에 저장하는데
        <code>this.</code>
        키워드를 통해 해당 클래스 변수에 접근하고 값이 저장됩니다. 생성자에 유의해야 할 점은 다음과 같습니다.</p>
      <ul>
        <li>생성자의 이름은 클래스와 같아야 합니다.</li>
        <li>반환 타입을 명시하지 않습니다.</li>
        <li>생성자는 여러 개 만들수 있습니다.</li>
        <li>생성자에서 초기화가 필요한 모든 필드를 초기화하는 것이 좋습니다.</li>
      </ul>
      <br>
      <p>생성자의 경우 여러개 만들수 있으며, 하나의 생성자만 있을 경우 기본 생성자를 대체합니다. 이러한 점을 활용해 다양한 초기값 유형에 대해 대처할 수 있습니다.</p>
      <pre class="line-numbers">
    <code class="language-java">class car {
        string name;
        string type;
        string company;
        int price;
        // 생성자 1
        public car(string name, string type, string company, int price) {
            this.name = name;
            this.type = type;
            this.company = company;
            this.price = price;
    
        }        
        // 생성자 2
        public car(string name, string company) {
            this.name = name;
            this.type = "truck";
            this.company = company;
            this.price = 300;
    
        }
    }
    
    public class main {
        public static void main(string[] args) {
            car car1 = new car("a", "van", "acompany", 150); // 생성자 1에 따라 초기값 지정 
            car car2 = new car("b", "bcompany"); // 생성자 2에 따라 초기값 지정
        }

    }</code>
    </pre>
    </li>
    <li>
      <strong>클래스 사용</strong>
      <p>이제 생성된 클래스 객체를 사용해보자 객체에서 값을 받아오는 방법은 다음과 같습니다.</p>
      <pre class="line-numbers">
    <code class="language-java">class car {
	    string name;
	    string type;
	    string company;
	    int price;
	
	    public car(string name, string type, string company, int price) {
	        this.name = name;
	        this.type = type;
	        this.company = company;
	        this.price = price;	
	    }
	
	    public void sale(int saleprice) { //입력된 가격만큼 할인
	        this.price -= saleprice;
	    }
	}
    
    public class main {
        public static void main(string[] args) {
	        system.out.println("car1 name is" + car1.name);
	        system.out.println("car1 price is" + car1.price);	
	        car1.sale(30);
	        system.out.println("car1 discounted price is " + car1.price);
        }

    }</code>
    </pre>
      <code>.</code>은 내부 클래스 변수나 메서드에 접근하기 위해 사용할 수 있습니다. 하지만 언제나 사용 가능한 것이 아닌데 이는 클래스 접근자에 의해 제어될 수 있기 때문입니다.
    </li>
    <li>
      <strong>클래스 접근 제어자</strong>
      <p>클래스 내부의 모든 변수와 메서드에 접근할 수 있다는 점은 불필요한 내부 구현을 드러내고 외부와의 연결에 혼란을 초래할 수 있습니다. 올바르지 않은 내부 접근은 코드의 안정성을 해치기도 합니다. 이를 방지하기 위해 접근제어자를 사용해 클래스 내부 메서드나 변수에 접근을 제어할 수 있습니다.</p>

      <ol>
        <li>
          <code>public</code>: 어디서든 접근할 수 있습니다. 클래스, 인터페이스, 메서드, 필드 등에 사용됩니다.</li>
        <li>
          <code>protected</code>: 같은 패키지 내의 클래스와 서브 클래스(상속받은 클래스)에서 접근할 수 있습니다. 클래스 외부에서는 접근할 수 없지만, 상속받은 클래스에서는 접근할 수 있습니다. 주로 상속 관계에서 사용됩니다.</li>
        <li>
          <code>default</code>
          (패키지 프라이빗, 명시적 키워드 없음): 같은 패키지 내의 클래스에서만 접근할 수 있습니다. 접근 제어자를 명시하지 않으면 기본적으로
          <code>default</code>
          접근 수준이 적용됩니다.</li>
        <li>
          <code>private</code>: 같은 클래스 내에서만 접근할 수 있습니다. 외부 클래스나 서브 클래스에서는 접근할 수 없습니다. 가장 제한적인 접근 수준입니다.</li>
      </ol>
      <div class="row">
        <div class="col-6">
          <pre class="line-numbers">
<code class="language-java">package mypackage;

public class myclass {
    //default 수준의 접근
    int defaultfield;
    void defaultmethod() {}
    
    //public 수준의 접근
    public int publicfield;
    public void publicmethod() {}        
    
    //protected 수준의 접근
    protected int protectedfield;
    protected void protectedmethod() {}    

    //private 수준의 접근    
    private int privatefield;
    private void privatemethod() {}
}</code>
                    </pre>
        </div>
        <div class="col-6">
          <pre class="line-numbers">
<code class="language-java">package mypackage;// 동일한 패키지
public class otherclass {
	 public static void main(string[] args) {
	    myclass myclass = new myclass();
	    // 동일 패키지에 대한 defalut 접근 가능!
	    myclass.defaultfield;
	 }
}</code>
                    </pre>

          <pre class="line-numbers">
<code class="language-java">public class subclass extends myclass{
    // myclass를 상속하는 클래스
     public static void main(string[] args) {
        myclass myclass = new myclass();
        // 상속 클래스 protected 접근 가능!
        myclass.protectedfield;
     }
}</code>
                    </pre>
        </div>
      </div>
    </li>
  </ol>
</div>

<!-- 상속 -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>상속</h1>
  </div>
  <p>프로그래머 'Tom'은 25세이며 'A'라는 이름의 회사를 다닙니다. Tom은 개와 고양이를 키우고 있습니다. 개는 'Max'이며 5살입니다. 고양이 'Lily'는 3살입니다. Tom은 Max와 걷고 달리기를 하지만 고양이 Lily는 게을러서 걷기만 하고, 대신 점프를 할 줄 압니다. 셋 모두 음식을 먹지만 그건 Tom이 일을 열심히 하기 때문입니다. Max는 멍멍! Lily는 야옹! Tom은 랄랄라~ 노래를 부릅니다.</p>
  <p>단란한 Tom네 집에 대해 Java 클래스로 표현해봅시다. 내용을 정리하면 다음과 같습니다.</p>

  <pre class="line-numbers">
    <code class="language-java">class programmer { // 프로그래머 클래스
	    string name; // 이름
	    int age; // 나이
	    string company; // 회사
	    int money; // 재산
	
	    programmer(string name, int age, string company) { // 생성자
	        this.name = name;
	        this.age = age;
	        this.company = company;
	        int money = 0;
	    }
	
	    void walk() {// 걷기
	        system.out.println(this.name + "is walking");
	    };
	
	    void run() {// 달리기
	        system.out.println(this.name + "is running");
	    };
	
	    void eat() {// 먹기
	        system.out.println(this.name + "is eating");
	    };
	
	    void work(int pay) {// 일하기
	        system.out.println(this.name + "is working");
	        this.money += pay;
	    };
	
	    void sing() {// 노래하기
	        system.out.println(this.name + "is singing: 랄랄라~");
	    };
	}
	
	class dog { // 개 클래스
	    string name; // 이름
	    int age; // 나이
	
	    dog(string name, int age) { // 생성자
	        this.name = name;
	        this.age = age;
	    }
	
	    void walk() {// 걷기
	        system.out.println(this.name + "is walking");
	    };
	
	    void run() {// 뛰기
	        system.out.println(this.name + "is running");
	    };
	
	    void eat() {// 먹기
	        system.out.println(this.name + "is eating");
	    };
	
	    void sing() {// 노래하기
	        system.out.println(this.name + "is singing: 멍멍~");
	    };
	
	}
	
	class cat { // 고양이 클래스
	    string name; // 이름
	    int age; // 나이
	
	    cat(string name, int age) { // 생성자
	        this.name = name;
	        this.age = age;
	    }
	
	    void walk() {// 걷기
	        system.out.println(this.name + "is walking");
	    };
	
	    void jump() {// 뛰기
	        system.out.println(this.name + "is running");
	    };
	
	    void eat() {// 먹기
	        system.out.println(this.name + "is eating");
	    };
	
	    void sing() {// 노래하기
	        system.out.println(this.name + "is singing: 냐옹~");
	    };
	
	}
	
	</code>
    </pre>

  <p>개와 고양이 그리고 프로그래머를 위한 세 개의 클래스가 만들어졌습니다. 동일한 변수와 메서드도 있지만 그 특성을 반영하는 차별화된 각자의 변수도 가지고 있습니다. 이대로 사용해도 좋습니다. 하지만 동일한 내용의 반복은 프로그래밍에 비효율적인 방법입니다. 만약 Tom이 돈을 많이 벌어서 펭귄과 호랑이, 금붕어와 앵무새까지 사게 되는 날에는 클래스가 계속 늘어날 것입니다. 반복되는 내용도 계속 늘어나고 코드의 유연성은 떨어질 것입니다. 공통된 내용을 묶어줄 수 있는 상속을 사용해보도록 합시다.</p>

  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>부모 클래스의 생성과 상속 활용</h1>
  </div>

  <p>공통된 내용(이름, 나이, 걷기, 먹기)를 포함하고 있는 Animal 클래스를 만들었습니다. 이를 상속하기 위해서는 클래스에
    <code>extends</code>
    키워드를 사용합니다. 상속한 클래스는
    <strong>부모 클래스</strong>, 상속 받은 클래스는
    <strong>자식 클래스</strong>라고 합니다. 자식 클래스는 부모 클래스에서 선언한 변수와 함수를 활용할 수 있습니다.
  </p>
  <pre class="line-numbers">
    <code class="language-java">class parent { // 부모 클래스
        int parentval; // 부모 클래스 변수
        void parentfun(){ // 부모 클래스 메서드
        }
    }
    
    class child extends parent { // 자식 클래스
        int childval; // 자식 클래스 변수
        void childfun(){ // 자식 클래스 메서드
        }
    }
    
    public class main {
        public static void main(string[] args) {
            child child = new child(); // 자식 클래스 인스턴스 생성
            child.patentval; // 자식 클래스가 부모에서 정의한 변수를 포함한다.
        }
    }</code>
    </pre>

  <p>자바 상속을 사용할 경우 다음과 같은 내용을 참고 합시다.</p>
  <ul>
    <li>
      <strong>is-a 관계 유지</strong>: 상속을 사용할 때는 반드시 자식 클래스가 부모 클래스의 일종이라는 is-a 관계가 성립해야 합니다. 예를 들어, Bird 클래스와 Penguin 클래스의 관계에서는 Penguin이 Bird의 일종이므로 상속이 적절합니다. 상속으로 표현하고자 하는 관계는 부모가 자식을 포함하는 더 큰 분류에 해당합니다.</li>
    <li>
      <strong>메서드 오버라이딩 (Overriding)</strong>: 부모 클래스가 정의한 내용을 자식 클래스가 따르도록 되어있지만 이를 자식 클래스가 재정의할 수도 있습니다. 이를 오버라이딩이라고 하며 자식 클래스에서 부모 클래스의 메서드를 재정의할 때는
      <code>@Override</code>
      애너테이션을 사용하여 컴파일러가 이를 확인하게 합니다.</li>
    <li>
      <strong>접근 제어자 (Access Modifiers)</strong>: 상속받은 메서드나 필드의 접근 제어자를 적절히 설정해야 합니다. 부모 클래스의
      <code>private</code>
      멤버는 자식 클래스에서 접근할 수 없으며,
      <code>protected</code>나
      <code>public</code>을 사용하면 접근할 수 있습니다.</li>
    <li>
      <strong>생성자 호출</strong>: 자식 클래스의 생성자에서 반드시 부모 클래스의 생성자를 호출해야 합니다.</li>
    <li>
      <strong>메서드 숨김(Method Hiding)</strong>: 부모 클래스의 static 메서드는 자식 클래스에서 오버라이딩할 수 없고, 같은 이름의 static 메서드를 정의하면 메서드 숨김이 발생합니다.</li>
    <li>
      <strong>업캐스팅(Upcasting)과 다운캐스팅(Downcasting)</strong>: 부모 클래스 타입의 참조 변수로 자식 클래스 객체를 참조할 수 있습니다(업캐스팅). 반대로, 자식 클래스 타입의 참조 변수로 부모 클래스 객체를 참조하려면 명시적 캐스팅이 필요합니다(다운캐스팅).</li>
    <li>
      <strong>다중 상속 불가</strong>: 자바는 다중 상속을 지원하지 않습니다. 이는 클래스 간의 복잡한 상속 관계와 충돌을 피하기 위함입니다. 다중 상속의 필요성이 있을 때는 인터페이스를 구현하는 방법을 사용합니다.</li>
  </ul>

  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>super</h1>
  </div>
  <p>상속의 개념에서 자식 클래스는 부모 클래스 요소에 대해 호출할 수 있습니다. 이는 super 키워드를 통해 가능합니다. 부모 클래스의 멤버(필드, 메서드, 생성자)를 자식 클래스에서 참조할 때 사용됩니다. 예시를 살펴봅시다.</p>

  <ol>
    <li>
      <strong>부모 클래스 생성자 호출</strong>
      <div class="row">

        <div class="col-6">
          <pre class="line-numbers">
    <code class="language-java">class parent {
        int b;
    
        parent(int b) {
            this.b = b;
        };
    }</code>
            </pre>

        </div>
        <div class="col-6">
          <pre class="line-numbers">
    <code class="language-java">class child extends parent {
        string a;
    
        child(string a) {
            a = "a";
        }
    }</code>
            </pre>
        </div>
      </div>
      <p>해당 코드는 오류가 발생합니다. 부모 클래스의 생성자는
        <code>int</code>값을 받아 클래스 변수에 저장합니다. 이를 상속하는 자식 클래스는 반면에
        <code>String</code>값을 받아서 클래스 변수에 저장합니다. 자식 클래스의 생성자만으로는 부모 클래스의 생성자를 만족할 수 없습니다. 따라서
        <code>super()</code>
        키워드를 통해서 부모 클래스의 생성자에 값을 전달해주어야 합니다.<br>(기본적으로 자식 클래스의 생성자는 자동으로
        <code>super()</code>가 포함되어 있습니다. 이는 파라미터가 없는 부모 클래스의 생성자를 의미합니다. 만약 부모 클래스의 생성자가 파라미터를 받지 않는다면 자식 클래스에
        <code>super()</code>
        키워드를 포함할 필요가 없습니다.)
      </p>
      <div class="row">

        <div class="col-6">
          <pre class="line-numbers">
    <code class="language-java">class parent {
        int b;
    
        parent(int b) {
            this.b = b;
        };
    }</code>
            </pre>

        </div>
        <div class="col-6">
          <pre class="line-numbers">
    <code class="language-java">class child extends parent {
        string a;    
        child(string a, int b) {
            super(b);
            a = "a";
        }
    }</code>
            </pre>
        </div>
      </div>
      <p>자식 클래스의 생성자에게 전달받는 두 값중
        <code>b</code>의 경우
        <code>super()</code>키워드를 따라 부모 클래스의 생성자로 이동합니다.
      </p>
    </li>
  </ol>
</div>

<!-- 다형성 -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>다형성</h1>
  </div>
  <p>다형성(Polymorphism)은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 동일한 인터페이스를 통해 서로 다른 데이터 타입들을 처리할 수 있는 기능을 의미합니다. 다형성은 코드의 유연성과 재사용성을 높이며, 유지보수를 용이하게 합니다. 자바에서 다형성은 주로 상속과 인터페이스를 통해 구현됩니다.</p>
  <p>다형성은 오버로딩과 오버라이딩 두 가지 방법이 있습니다.</p>

  <ul>
    <li>
      <strong>메서드 오버로딩</strong>: 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 타입이나 개수를 다르게 하여 구현하는 방식입니다. 이는 컴파일 시간 다형성의 한 예입니다.</li>
    <li>
      <strong>메서드 오버라이딩</strong>: 상위 클래스의 메서드를 하위 클래스에서 재정의하는 방식입니다. 이는 런타임 다형성의 한 예입니다.</li>
  </ul>

  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>오버라이딩</h1>
  </div>

  <p>해당 내용을 참고하여 Tom의 집을 다시 만들어 봅시다. 상속을 위해서는 공통된 내용을 묶어줄 수 있는 부모 클래스를 만들어야 합니다. Animal 클래스를 만들고 이를 상속받는 클래스를 만들어봅시다.</p>
  <pre class="line-numbers">
  <code class="language-java">class animal {
      string name; // 이름
      int age; // 나이
  
      public animal(string name, int age) {
          this.name = name;
          this.age = age;
      }
      void walk() {// 걷기
          system.out.println(this.name + "is walking");
      };
      void eat() {// 먹기
          system.out.println(this.name + "is eating");
      };
  }
  
  class dog extends animal { // 자식 클래스 - 개

    dog(string name, int age) { // 생성자
        super(name, age);
    }

    void run() {// 뛰기
        system.out.println(this.name + "is running");
    };

    void sing() {// 노래하기
        system.out.println(this.name + "is singing: 랄랄라~");
    };

}

class cat extends animal { // 자식 클래스 - 고양이

    cat(string name, int age) { // 생성자
        super(name, age);
    }

    void jump() {// 뛰기
        system.out.println(this.name + "is running");
    };

    void sing() {// 노래하기
        system.out.println(this.name + "is singing: 랄랄라~");
    };

}

class programmer extends animal {// 자식 클래스 - 프로그래머
    string company; // 회사
    int money; // 재산

    programmer(string name, int age, string company) { // 생성자
        super(name, age);
        this.company = company;
        int money = 0;
    }

    void run() {// 달리기
        system.out.println(this.name + "is running");
    };     

    void work(int pay) {// 일하기
        system.out.println(this.name + "is working");
        this.money += pay;
    };

    void sing() {// 노래하기
        system.out.println(this.name + "is singing: 랄랄라~");
    };
}</code>
  </pre>
  <img src="resources/img/inheri.png">

  <pre class="line-numbers">
  <code class="language-java">public class main {
    public static void main(string[] args) {

        programmer tom = new programmer("tom", 25, "a");
        dog max = new dog("max", 5);
        cat lily = new cat("lily", 3);

        // 다 함께 산책
        tom.walk();
        max.walk();
        lily.walk();

        // 운동 시간
        tom.run();
        max.run();
        lily.jump();

        // 톰은 돈을 벌어야 해요!
        tom.work(1000);
    }
}</code>
  </pre>

  <p>정리하자면,
    <strong>상속</strong>이라는 개념은 클래스를 구성할 때 부모 클래스를 만들고 공통된 내용을 포함한 자식 클래스에 상속해주는 것을 의미한다.</p>
</div>

<!-- 추상화 -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>추상화</h1>
  </div>
  <p>자바에서 추상화(Abstraction)는 객체 지향 프로그래밍의 중요한 개념 중 하나로, 복잡한 시스템을 단순화하여 이해하기 쉽도록 만드는 과정입니다. 추상화는 구체적인 구현 세부 사항을 숨기고, 필요한 기능이나 특성만을 노출함으로써 사용자에게 편리한 인터페이스를 제공합니다. 이를 통해 코드를 보다 읽기 쉽게 만들고 유지보수를 용이하게 합니다.</p>
  <p>자바에서 추상화를 구현하는 두 가지 주요 도구는 추상 클래스(Abstract Class)와 인터페이스(Interface)입니다.</p>

  <h3>추상 클래스</h3>
  <p>추상 클래스는 하나 이상의 추상 메서드(구현이 없는 메서드)를 포함할 수 있는 클래스입니다. 추상 클래스는 객체를 직접 생성할 수 없으며, 이를 상속받은 하위 클래스가 추상 메서드를 구현해야 합니다. 추상 클래스는 다음과 같은 특징을 가집니다.</p>
  <ul>
    <li>
      <strong>공통 기능의 제공</strong>: 여러 하위 클래스에 공통으로 사용될 수 있는 메서드나 필드를 정의할 수 있습니다.</li>
    <li>
      <strong>부분적인 구현</strong>: 일부 메서드는 구현하고, 일부 메서드는 추상 메서드로 남겨두어 하위 클래스에서 구현하게 할 수 있습니다.</li>
  </ul>

  <h3>인터페이스</h3>
  <p>인터페이스는 모든 메서드가 추상 메서드로만 이루어져 있는 구조입니다. 자바 8부터는 디폴트 메서드와 정적 메서드를 인터페이스에 포함할 수 있게 되었지만, 기본적으로 인터페이스는 메서드의 서명(signature)만 정의하고 구현은 제공하지 않습니다. 인터페이스의 주요 특징은 다음과 같습니다.</p>
  <ul>
    <li>
      <strong>다중 상속</strong>: 자바는 클래스의 다중 상속을 지원하지 않지만, 인터페이스는 여러 개를 구현할 수 있습니다.</li>
    <li>
      <strong>계약(Contract) 역할</strong>: 특정 클래스가 어떤 메서드를 반드시 구현해야 하는지를 명시합니다.</li>
  </ul>

  <h3>추상화의 이점</h3>
  <ol>
    <li>
      <strong>코드의 재사용성 증가</strong>: 추상 클래스와 인터페이스를 통해 공통의 기능을 정의하고 재사용할 수 있습니다.</li>
    <li>
      <strong>유지보수 용이</strong>: 코드의 구조가 명확해져 변경이 필요할 때 특정 부분만 수정하면 되므로 유지보수가 쉽습니다.</li>
    <li>
      <strong>유연성 향상</strong>: 인터페이스를 사용하여 다형성을 구현하면, 다양한 구현체를 교체하여 사용할 수 있어 코드의 유연성이 증가합니다.</li>
    <li>
      <strong>캡슐화</strong>: 추상화는 세부 구현을 감추고 외부에 필요한 기능만 노출함으로써 캡슐화를 강화합니다.</li>
  </ol>
  <p>결론적으로, 추상화는 자바에서 중요한 설계 원칙으로, 복잡성을 줄이고 코드의 가독성과 유지보수성을 높이는 데 크게 기여합니다. 추상 클래스와 인터페이스를 적절히 활용하면 더 구조적이고 유연한 프로그램을 작성할 수 있습니다.</p>

</div>

<!-- 캡슐화 -->
<div>
  <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1>캡슐화</h1>
  </div>
  <p>캡슐화(Encapsulation)는 객체 지향 프로그래밍의 핵심 개념 중 하나로, 객체의 데이터(상태)와 그 데이터를 조작하는 메서드(행동)를 하나의 단위로 묶는 것을 의미합니다. 캡슐화를 통해 데이터의 접근을 제한하고, 객체 내부의 데이터 변조를 방지하여 코드의 안정성과 보안성을 높일 수 있습니다.</p>

  <ul>
    <li>
      <strong>데이터 은닉(Data Hiding)</strong>: 객체의 내부 데이터를 외부에서 직접 접근하지 못하게 하여, 데이터를 보호하고 무결성을 유지합니다.</li>
    <li>
      <strong>공용 인터페이스 제공</strong>: 객체의 데이터를 조작할 수 있는 공용 메서드를 제공하여, 데이터의 접근과 변경을 제어합니다.</li>
  </ul>

  <h3>접근 제어자와 Getter, Setter</h3>
  <p>자바에서 캡슐화를 구현하는 방법은 주로 접근 제어자(Access Modifiers)를 사용하는 것입니다. 자바는 네 가지 주요 접근 제어자를 제공합니다:</p>
  <ul>
    <li>
      <strong>public</strong>: 같은 클래스 내에서만 접근 가능합니다.</li>
    <li>
      <strong>private</strong>: 같은 패키지 내에서만 접근 가능합니다.</li>
    <li>
      <strong>protected</strong>: 같은 패키지 내 및 상속받은 클래스에서 접근 가능합니다.</li>
    <li>
      <strong>default</strong>: 모든 클래스에서 접근 가능합니다.</li>
  </ul>

  <p>이러한 캡슐화를 통해 내부 데이터를 숨길 수 있습니다. 숨겨진 내부 데이터에 대한 호출과 변경의 경우 메서드를 활용합니다. 값의 호출은 Getter, 값의 변경은 Setter 함수에 해당합니다.</p>

</div>
